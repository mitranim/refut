/*
Utilities missing from the "reflect" package: easier struct traversal, deep
dereferencing, various boolean tests such as generic `IsNil` or `IsEmpty`, and
some more. Small and dependency-free.

Naming Conventions

• Functions that take a `reflect.Value` have "Rval" in the name.

• Functions that take a `reflect.Type` have "Rtype" in the name.

API Considerations

In general, utils for struct traversal can be implemented as function that take
closures, or as stateful iterator objects. Both approaches were tested and
demonstrated similar performance characteristics. The iterator-based approach
can be more convenient to use because it doesn't interrupt the control flow of
the caller code. However, the closure-based approach is much simpler to
implement and get right. It's also much simpler to wrap, making it easier for
users of this package to implement their own iterator functions in terms of the
existing ones.
*/
package refut

import (
	"errors"
	"reflect"
	"strings"
)

var (
	ErrMissingFunc  = Error(`refut: missing callback function`)
	ErrInvalidType  = Error(`refut: received invalid type`)
	ErrInvalidValue = Error(`refut: received invalid value`)
)

// Type of errors generated by this package.
type Error string

// Implement `error`.
func (self Error) Error() string { return string(self) }

// Implement a hidden interface in "errors".
func (self Error) Is(other error) bool {
	var err Error
	return errors.As(other, &err) && self == err
}

/*
Takes a struct value and traverses its fields, calling the provided function for
each field. Skips non-exported (private) fields. Traverses the fields of
embedded structs as if they were part of the enclosing struct.

The callback receives arguments for a specific struct field:

• `reflect.Value`: field value.

• `reflect.StructField`: field description.

• `[]int`: path to the field, which can be passed to
`reflect.Value.FieldByIndex` on the root value.

See `TraverseStructType` for notes about the `[]int` path.

The input may be a struct pointer, which is automatically dereferenced. A nil
pointer causes a panic.

If the input is not a struct, or if the callback is nil, this function panics.
Returned errors are always from the callback.
*/
func TraverseStruct(val interface{}, fun func(reflect.Value, reflect.StructField, []int) error) error {
	return TraverseStructRval(reflect.ValueOf(val), fun)
}

/*
Variant of `TraverseStruct` that takes a `reflect.Value` as the input. See
`TraverseStruct` for the documentation.

If the input is not a struct, or if the callback is nil, this function panics.
Returned errors are always from the callback.
*/
func TraverseStructRval(rval reflect.Value, fun func(reflect.Value, reflect.StructField, []int) error) error {
	rval = onlyStructRval(RvalDeref(rval))
	if fun == nil {
		panic(ErrMissingFunc)
	}

	return TraverseStructRtype(rval.Type(), func(sfield reflect.StructField, path []int) error {
		return fun(rval.FieldByIndex(path), sfield, path)
	})
}

/*
Takes a struct value and traverses the fields of its type, calling the provided
function for each field. Skips non-exported (private) fields. Traverses the
fields of embedded structs as if they were part of the enclosing struct.

This function is provided for convenience; it ignores the actual value of its
input. The input may be a struct or a struct pointer. Nil pointers are okay.

The callback receives arguments for a specific struct field:

• `reflect.StructField`: field description.

• `[]int`: path to the field, which can be passed to `reflect.Type.FieldByIndex`
on the root value.

The reason the path is a slice of ints, rather than one int, is because
addressing a field of an embedded struct requires more than one index. See
`reflect.Type.FieldByIndex`. WARNING: the path slice is allocated once and
mutated between iterations. To store the path for later use, you MUST copy the
slice.

If the input is not a struct type, or if the callback is nil, this function
panics. Returned errors are always from the callback.
*/
func TraverseStructType(val interface{}, fun func(reflect.StructField, []int) error) error {
	return TraverseStructRtype(reflect.TypeOf(val), fun)
}

/*
Variant of `TraverseStructType` that takes a `reflect.Type` as the input. See
`TraverseStruct` for the documentation.

If the input is not a struct type, or if the callback is nil, this function
panics. Returned errors are always from the callback.
*/
func TraverseStructRtype(rtype reflect.Type, fun func(reflect.StructField, []int) error) error {
	return traverseStructRtype(rtype, fun, nil)
}

func traverseStructRtype(rtype reflect.Type, fun func(reflect.StructField, []int) error, path []int) error {
	rtype = onlyStructRtype(RtypeDeref(rtype))
	if fun == nil {
		panic(ErrMissingFunc)
	}

	for i := 0; i < rtype.NumField(); i++ {
		sfield := rtype.Field(i)
		if !IsSfieldExported(sfield) {
			continue
		}

		/**
		If this is an embedded struct, traverse its fields as if they're in the
		parent struct.
		*/
		if sfield.Anonymous && RtypeDeref(sfield.Type).Kind() == reflect.Struct {
			path = append(path, i)
			err := traverseStructRtype(sfield.Type, fun, path)
			if err != nil {
				return err
			}
			path = path[:len(path)-1]
			continue
		}

		path = append(path, i)
		err := fun(sfield, path)
		if err != nil {
			return err
		}
		path = path[:len(path)-1]
	}

	return nil
}

/*
Takes a struct field tag and returns the identifier part contained in it, as
long as the tag follows the convention established by `json:""` tags:

	json:"ident"
	json:"ident,<extra>"
	json:"-"
	json:"-,<extra>"

Ident "-" is converted to "".

Usage:

	ident := TagIdent(sfield.Tag.Get("json"))
	ident := TagIdent(sfield.Tag.Get("db"))
*/
func TagIdent(tag string) string {
	index := strings.IndexRune(tag, ',')
	if index >= 0 {
		return TagIdent(tag[:index])
	}
	if tag == "-" {
		return ""
	}
	return tag
}

func IsSfieldExported(sfield reflect.StructField) bool {
	return sfield.PkgPath == ""
}

/*
Takes a `reflect.Type` and dereferences as many times as needed, until it's no
longer a pointer type. A nil type is ok and returns nil.

Note: if the type is defined recursively as a pointer to itself, this will loop
forever.
*/
func RtypeDeref(rtype reflect.Type) reflect.Type {
	for rtype != nil && rtype.Kind() == reflect.Ptr {
		rtype = rtype.Elem()
	}
	return rtype
}

/*
Takes a `reflect.Value` and dereferences as many times as needed, until it's no
longer a pointer. Panics if any pointer in the sequence is nil.

Note: if the type is defined recursively as a pointer to itself, this will loop
forever.
*/
func RvalDeref(rval reflect.Value) reflect.Value {
	for rval.Kind() == reflect.Ptr {
		rval = rval.Elem()
	}
	return rval
}

/*
Shortcut for `reflect.TypeOf(val).Kind()`. Returns `reflect.Invalid` for a nil
input.
*/
func KindOf(val interface{}) reflect.Kind {
	if val == nil {
		return reflect.Invalid
	}
	return reflect.TypeOf(val).Kind()
}

/*
Returns true if the kind of the provided value is nilable. See `IsRkindNilable`
for further details. As a special case, this returns true for a nil input, even
though it carries no type information.
*/
func IsNilable(val interface{}) bool {
	return val == nil || IsRkindNilable(KindOf(val))
}

/*
Returns true for the kinds "reflect" considers nilable: chan, func, interface,
map, pointer, or slice. These are the kinds for which it's safe to call
`reflect.Value.IsNil` without panicking.
*/
func IsRkindNilable(kind reflect.Kind) bool {
	switch kind {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
		return true
	default:
		return false
	}
}

/*
Similar to `X == nil`, but returns true if the input is a non-nil `interface{}`
whose underlying concrete type is nilable (pointer, slice, map, channel, func)
and its underlying concrete val is nil.
*/
func IsNil(val interface{}) bool {
	return val == nil || IsRvalNil(reflect.ValueOf(val))
}

/*
Variant of `IsNil` that takes a `reflect.Value` as input. See `IsNil` for the
documentation.
*/
func IsRvalNil(rval reflect.Value) bool {
	return !rval.IsValid() || IsRkindNilable(rval.Kind()) && rval.IsNil()
}

/*
Returns true if the kind of the provided value is a collection. See
`IsRkindColl` for further details. Note that this follows `reflect.Value.Len`
rather than the built-in `len` in that pointers to arrays are not considered to
be collections.
*/
func IsColl(val interface{}) bool {
	return IsRkindColl(KindOf(val))
}

/*
Returns true for the kinds "reflect" considers collections: array, chan, map,
slice, or string. These are the kinds for which it's safe to call
`reflect.Value.Len` without panicking.
*/
func IsRkindColl(kind reflect.Kind) bool {
	switch kind {
	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:
		return true
	default:
		return false
	}
}

/*
Returns true if the input belongs to one of the kinds "reflect" considers
collections (see `IsRkindColl`), and has the length of zero. Nils are included.
*/
func IsEmptyColl(val interface{}) bool {
	return IsRvalEmptyColl(reflect.ValueOf(val))
}

/*
Variant of `IsEmpty` that takes a `reflect.Value` as input. See `IsEmpty` for
the documentation.
*/
func IsRvalEmptyColl(rval reflect.Value) bool {
	return IsRkindColl(rval.Kind()) && rval.Len() == 0
}

func onlyStructRtype(rtype reflect.Type) reflect.Type {
	if rtype != nil && rtype.Kind() == reflect.Struct {
		return rtype
	}
	panic(ErrInvalidType)
}

func onlyStructRval(rval reflect.Value) reflect.Value {
	if rval.Kind() == reflect.Struct {
		return rval
	}
	panic(ErrInvalidValue)
}
