/*
Utilities missing from the "reflect" package: easier struct traversal, deep
dereferencing, various boolean tests such as generic `IsNil`, and some more.
Small and dependency-free.

Naming Conventions

• Functions that take a `reflect.Value` have "Rval" in the name.

• Functions that take a `reflect.Type` have "Rtype" in the name.

API Considerations

In general, utils for struct traversal can be implemented as function that take
closures, or as stateful iterator objects. Both approaches were tested and
demonstrated similar performance characteristics. The iterator-based approach
can be more convenient to use because it doesn't interrupt the control flow of
the caller code. However, the closure-based approach is much simpler to
implement and get right. It's also much simpler to wrap, making it easier for
users of this package to implement their own iterator functions in terms of the
existing ones.
*/
package refut

import (
	"errors"
	"reflect"
	"strings"
)

var (
	ErrMissingFunc  = Error(`refut: missing callback function`)
	ErrInvalidType  = Error(`refut: received invalid type`)
	ErrInvalidValue = Error(`refut: received invalid value`)
)

// Type of errors generated by this package.
type Error string

// Implement `error`.
func (self Error) Error() string { return string(self) }

// Implement a hidden interface in "errors".
func (self Error) Is(other error) bool {
	var err Error
	return errors.As(other, &err) && self == err
}

/*
Takes a struct value and traverses its fields, calling the provided function for
each field. Skips non-exported (private) fields. Traverses the fields of
embedded structs as if they were part of the enclosing struct.

The callback receives arguments for a specific struct field:

• `reflect.Value`: field value.

• `reflect.StructField`: field description.

• `[]int`: path to the field, suitable for `reflect.Value.FieldByIndex` or
`RvalFieldByPathAlloc` on the root value. See `TraverseStructType` for notes
about the path.

WARNING: the path slice is allocated once and mutated between iterations. To
store the path for later use, you MUST copy the slice.

The input may be a struct pointer, which is automatically dereferenced. Nil
struct pointers at the root level or as embedded fields are okay and won't be
traversed.

If the input is not a struct, or if the callback is nil, this function panics.
Returned errors are always from the callback.
*/
func TraverseStruct(val interface{}, fun func(reflect.Value, reflect.StructField, []int) error) error {
	return TraverseStructRval(reflect.ValueOf(val), fun)
}

/*
Variant of `TraverseStruct` that takes a `reflect.Value` as the input. See
`TraverseStruct` for the documentation.

If the input is not a struct, or if the callback is nil, this function panics.
Returned errors are always from the callback.
*/
func TraverseStructRval(rval reflect.Value, fun func(reflect.Value, reflect.StructField, []int) error) error {
	return traverseStructRval(rval, fun, nil)
}

func traverseStructRval(rval reflect.Value, fun func(reflect.Value, reflect.StructField, []int) error, path []int) error {
	// Deref and validate the type first, because we might not fully deref the
	// value to check its type.
	rtype := RtypeDeref(rval.Type())
	if rtype.Kind() != reflect.Struct {
		panic(ErrInvalidValue)
	}

	if fun == nil {
		panic(ErrMissingFunc)
	}

	for rval.Kind() == reflect.Ptr {
		// Nil struct pointers are okay and not traversed.
		if rval.IsNil() {
			return nil
		}
		rval = rval.Elem()
	}

	for i := 0; i < rtype.NumField(); i++ {
		sfield := rtype.Field(i)
		if !IsSfieldExported(sfield) {
			continue
		}

		/**
		If this is an embedded struct, traverse its fields as if they're in the
		parent struct. If the embedded struct is a nil pointer, skip it.
		*/
		if sfield.Anonymous && RtypeDeref(sfield.Type).Kind() == reflect.Struct {
			path = append(path, i)
			err := traverseStructRval(rval.Field(i), fun, path)
			if err != nil {
				return err
			}
			path = path[:len(path)-1]
			continue
		}

		path = append(path, i)
		err := fun(rval.Field(i), sfield, path)
		if err != nil {
			return err
		}
		path = path[:len(path)-1]
	}

	return nil
}

/*
Takes a struct value and traverses the fields of its type, calling the provided
function for each field. Skips non-exported (private) fields. Traverses the
fields of embedded structs as if they were part of the enclosing struct.

This function is provided for convenience; it ignores the actual value of its
input. The input may be a struct or a struct pointer. Nil pointers are okay.

The callback receives arguments for a specific struct field:

• `reflect.StructField`: field description.

• `[]int`: path to the field.

The reason the path is a slice of ints, rather than one int, is because
addressing a field of an embedded struct requires more than one index. The path
is suitable for `reflect.Type.FieldByIndex` on the root type or
`RvalFieldByPathAlloc` on a value of that type.

WARNING: the path slice is allocated once and mutated between iterations. To
store the path for later use, you MUST copy the slice.

If the input is not a struct type, or if the callback is nil, this function
panics. Returned errors are always from the callback.
*/
func TraverseStructType(val interface{}, fun func(reflect.StructField, []int) error) error {
	return TraverseStructRtype(reflect.TypeOf(val), fun)
}

/*
Variant of `TraverseStructType` that takes a `reflect.Type` as the input. See
`TraverseStruct` for the documentation.

If the input is not a struct type, or if the callback is nil, this function
panics. Returned errors are always from the callback.
*/
func TraverseStructRtype(rtype reflect.Type, fun func(reflect.StructField, []int) error) error {
	rtype = RtypeDeref(rtype)
	validateStructRtype(rtype)
	if fun == nil {
		panic(ErrMissingFunc)
	}
	return traverseStructRtype(rtype, fun, nil)
}

func traverseStructRtype(rtype reflect.Type, fun func(reflect.StructField, []int) error, path []int) error {
	for i := 0; i < rtype.NumField(); i++ {
		sfield := rtype.Field(i)
		if !IsSfieldExported(sfield) {
			continue
		}

		/**
		If this is an embedded struct, traverse its fields as if they're in the
		parent struct.
		*/
		if sfield.Anonymous {
			fieldRtype := RtypeDeref(sfield.Type)
			if fieldRtype.Kind() == reflect.Struct {
				path = append(path, i)
				err := traverseStructRtype(fieldRtype, fun, path)
				if err != nil {
					return err
				}
				path = path[:len(path)-1]
				continue
			}
		}

		path = append(path, i)
		err := fun(sfield, path)
		if err != nil {
			return err
		}
		path = path[:len(path)-1]
	}

	return nil
}

/*
Takes a struct field tag and returns the identifier part contained in it, as
long as the tag follows the convention established by `json:""` tags:

	json:"ident"
	json:"ident,<extra>"
	json:"-"
	json:"-,<extra>"

Ident "-" is converted to "".

Usage:

	ident := TagIdent(sfield.Tag.Get("json"))
	ident := TagIdent(sfield.Tag.Get("db"))
*/
func TagIdent(tag string) string {
	index := strings.IndexRune(tag, ',')
	if index >= 0 {
		return TagIdent(tag[:index])
	}
	if tag == "-" {
		return ""
	}
	return tag
}

func IsSfieldExported(sfield reflect.StructField) bool {
	return sfield.PkgPath == ""
}

/*
Takes a `reflect.Type` and dereferences as many times as needed until it's no
longer a pointer type. A nil type is ok and returns nil.

Note: if the type is defined recursively as a pointer to itself, this will loop
forever.
*/
func RtypeDeref(rtype reflect.Type) reflect.Type {
	for rtype != nil && rtype.Kind() == reflect.Ptr {
		rtype = rtype.Elem()
	}
	return rtype
}

/*
Takes a `reflect.Value` and dereferences as many times as needed until it's no
longer a pointer. Panics if any pointer in the sequence is nil.

Note: if the type is defined recursively as a pointer to itself, this will loop
forever.
*/
func RvalDeref(rval reflect.Value) reflect.Value {
	for rval.Kind() == reflect.Ptr {
		rval = rval.Elem()
	}
	return rval
}

/*
Takes a `reflect.Value` and dereferences as many times as needed until it's no
longer a pointer, while allocating intermediary values as necessary. If the
input value is a pointer, it must be settable or non-nil, otherwise this causes
a panic.

Example:

	var val ***string
	rval := refut.RvalDerefAlloc(reflect.ValueOf(&val))
	rval.SetString("hello world")
	fmt.Println(***val) // "hello world"
*/
func RvalDerefAlloc(rval reflect.Value) reflect.Value {
	for rval.Kind() == reflect.Ptr {
		if rval.IsNil() {
			rval.Set(reflect.New(rval.Type().Elem()))
		}
		rval = rval.Elem()
	}
	return rval
}

/*
Variant of `reflect.Value.FieldByIndex` that allocates intermediary values for
fields which are struct pointers. For example:

	type Inner struct { Value string }
	type Outer struct { *Inner }

	var outer Outer
	rval := refut.RvalFieldByPathAlloc(reflect.ValueOf(&outer), []int{0, 0})
	rval.SetString("hello world")
	fmt.Println(outer.Value) // "hello world"

Unlike `reflect.Value.FieldByIndex`, this function also allows the input value
to be a non-nil struct pointer of any depth, as seen in the example above.
*/
func RvalFieldByPathAlloc(rval reflect.Value, path []int) reflect.Value {
	rval = RvalDerefAlloc(rval)
	if rval.Kind() != reflect.Struct {
		panic(ErrInvalidValue)
	}

	switch len(path) {
	case 0:
		return rval
	case 1:
		return rval.Field(path[0])
	default:
		return RvalFieldByPathAlloc(rval.Field(path[0]), path[1:])
	}
}

/*
Shortcut for `reflect.TypeOf(val).Kind()`. Returns `reflect.Invalid` for a nil
input.
*/
func KindOf(val interface{}) reflect.Kind {
	if val == nil {
		return reflect.Invalid
	}
	return reflect.TypeOf(val).Kind()
}

/*
Returns true if the kind of the provided value is nilable. See `IsRkindNilable`
for further details. As a special case, this returns true for a nil input, even
though it carries no type information.
*/
func IsNilable(val interface{}) bool {
	return val == nil || IsRkindNilable(KindOf(val))
}

/*
Returns true for the kinds "reflect" considers nilable: chan, func, interface,
map, pointer, or slice. These are the kinds for which it's safe to call
`reflect.Value.IsNil` without panicking.
*/
func IsRkindNilable(kind reflect.Kind) bool {
	switch kind {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
		return true
	default:
		return false
	}
}

/*
Similar to `X == nil`, but returns true if the input is a non-nil `interface{}`
whose underlying concrete type is nilable (pointer, slice, map, channel, func)
and its underlying concrete val is nil.
*/
func IsNil(val interface{}) bool {
	return val == nil || IsRvalNil(reflect.ValueOf(val))
}

/*
Variant of `IsNil` that takes a `reflect.Value` as input. See `IsNil` for the
documentation.
*/
func IsRvalNil(rval reflect.Value) bool {
	return !rval.IsValid() || IsRkindNilable(rval.Kind()) && rval.IsNil()
}

/*
Returns true if the kind of the provided value is a collection. See
`IsRkindColl` for further details. Note that this follows `reflect.Value.Len`
rather than the built-in `len` in that pointers to arrays are not considered to
be collections.
*/
func IsColl(val interface{}) bool {
	return IsRkindColl(KindOf(val))
}

/*
Returns true for the kinds "reflect" considers collections: array, chan, map,
slice, or string. These are the kinds for which it's safe to call
`reflect.Value.Len` without panicking.
*/
func IsRkindColl(kind reflect.Kind) bool {
	switch kind {
	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:
		return true
	default:
		return false
	}
}

/*
Returns true if the input belongs to one of the kinds "reflect" considers
collections (see `IsRkindColl`), and has the length of zero. Nils are included.
*/
func IsEmptyColl(val interface{}) bool {
	return IsRvalEmptyColl(reflect.ValueOf(val))
}

/*
Variant of `IsEmpty` that takes a `reflect.Value` as input. See `IsEmpty` for
the documentation.
*/
func IsRvalEmptyColl(rval reflect.Value) bool {
	return IsRkindColl(rval.Kind()) && rval.Len() == 0
}

func validateStructRtype(rtype reflect.Type) {
	if rtype != nil && rtype.Kind() == reflect.Struct {
		return
	}
	panic(ErrInvalidType)
}
